<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Timer App</title>
    <style>
        /* Universal styles that work on all devices and orientations */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f0f8ff; /* Light blue background */
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            overflow: hidden; /* Prevent scrollbars from canvas effects */
        }

        /* Canvas for special effects */
        #effectsCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to timer */
            z-index: 1000;
        }

        /* Main timer display - large and centered */
        #timer {
            font-size: 8vw; /* Responsive font size using viewport width */
            color: dodgerblue;
            font-weight: bold;
            text-align: center;
            margin: 20px 0;
            display: none; /* Hidden initially */
            min-height: 20vh; /* Ensure consistent height */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Instructions text */
        #instructions {
            font-size: 3vw;
            color: #333366;
            text-align: center;
            margin: 20px;
            padding: 20px;
            max-width: 80%;
            line-height: 1.5;
        }

        /* Leaderboard container */
        #leaderboard {
            display: none;
            width: 85%;
            max-width: 400px;
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin-top: 15px;
            max-height: 60vh;
            overflow-y: auto;
        }

        #leaderboard h2 {
            color: #333366;
            text-align: center;
            margin-bottom: 15px;
            font-size: 1vw;
        }

        /* Individual score entries */
        .score-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f0f8ff;
            padding: 10px;
            margin: 8px 0;
            border-radius: 5px;
            font-size: 1vw;
            color: #333366;
        }

        .score-entry span {
            font-weight: bold;
        }

        /* Delete button for each score */
        .delete-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1vw;
            transition: background 0.3s;
        }

        .delete-btn:hover {
            background: #cc0000;
        }

        /* Status message */
        #status {
            font-size: 3vw;
            color: #555555;
            text-align: center;
            margin: 20px;
            font-weight: bold;
        }

        /* Responsive adjustments for different screen sizes */
        @media (max-width: 768px) {
            #timer {
                font-size: 12vw;
            }
            
            #instructions {
                font-size: 4vw;
            }
            
            #leaderboard h2 {
                font-size: 4vw;
            }
            
            .score-entry {
                font-size: 3vw;
                padding: 8px;
            }
            
            .delete-btn {
                font-size: 2.5vw;
                padding: 4px 8px;
            }
            
            #status {
                font-size: 4vw;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            #timer {
                font-size: 10vh;
            }
            
            #instructions {
                font-size: 3vh;
            }
            
            #leaderboard h2 {
                font-size: 4vh;
            }
            
            .score-entry {
                font-size: 2.5vh;
                padding: 8px;
            }
            
            .delete-btn {
                font-size: 2vh;
                padding: 4px 8px;
            }
        }
    </style>
</head>
<body>
    <!-- Canvas for lightning effects -->
    <canvas id="effectsCanvas"></canvas>
    
    <!-- Instructions shown initially -->
    <div id="instructions">
        <h1 style="color: dodgerblue; margin-bottom: 20px;">Universal Timer App</h1>
        <p><strong>Press and hold</strong> anywhere on the screen to prepare the timer</p>
        <p><strong>Release</strong> to start timing</p>
        <p><strong>Press again</strong> to stop and save your time</p>
        <p>Works on PC (mouse) and mobile (touch) in any orientation!</p>
    </div>

    <!-- Timer display -->
    <div id="timer">0.000s</div>

    <!-- Status message -->
    <div id="status"></div>

    <!-- Leaderboard -->
    <div id="leaderboard">
        <h2>üèÜ Top 5 Times</h2>
        <div id="scores-container"></div>
    </div>

    <script>
        // Canvas setup for lightning effects
        const canvas = document.getElementById('effectsCanvas');
        const ctx = canvas.getContext('2d');
        
        // Resize canvas to match window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Lightning effect variables
        let mouseX = 0;
        let mouseY = 0;
        let lightningBolts = [];
        let glowIntensity = 0;
        let lastLightningTime = 0;
        let isEffectsActive = false; // Only show effects when pressed
        let glowAnimation = 0; // For animated glow effects
        
        // Lightning bolt class
        class LightningBolt {
            constructor(startX, startY, endX, endY) {
                this.points = [];
                this.life = 1.0;
                this.decay = 0.08;
                this.thickness = Math.random() * 2 + 0.5; // Smaller thickness
                this.color = this.getRandomColor();
                this.animationOffset = Math.random() * Math.PI * 2;
                
                // Generate jagged lightning path - smaller bolts
                const segments = 6;
                const distance = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
                const maxDistance = 40; // Smaller lightning bolts
                
                if (distance > maxDistance) {
                    const ratio = maxDistance / distance;
                    endX = startX + (endX - startX) * ratio;
                    endY = startY + (endY - startY) * ratio;
                }
                
                for (let i = 0; i <= segments; i++) {
                    const progress = i / segments;
                    const x = startX + (endX - startX) * progress + (Math.random() - 0.5) * 15;
                    const y = startY + (endY - startY) * progress + (Math.random() - 0.5) * 15;
                    this.points.push({ x, y });
                }
            }
            
            getRandomColor() {
                const colors = [
                    'rgba(100, 149, 237, ', // Cornflower blue
                    'rgba(30, 144, 255, ',  // Dodger blue
                    'rgba(65, 105, 225, ',  // Royal blue
                    'rgba(255, 255, 255, ', // White
                    'rgba(135, 206, 235, ', // Sky blue
                    'rgba(173, 216, 230, '  // Light blue
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            update() {
                this.life -= this.decay;
                this.animationOffset += 0.3;
                return this.life > 0;
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                
                ctx.save();
                
                // Animated alpha and thickness
                const animatedAlpha = this.life * (0.8 + 0.2 * Math.sin(this.animationOffset));
                const animatedThickness = this.thickness * (0.7 + 0.3 * Math.sin(this.animationOffset * 1.5));
                
                ctx.globalAlpha = animatedAlpha;
                ctx.strokeStyle = this.color + animatedAlpha + ')';
                ctx.lineWidth = animatedThickness;
                ctx.lineCap = 'round';
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color + '0.6)';
                
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                
                ctx.stroke();
                ctx.restore();
            }
        }
        
        // Create lightning bolts around cursor
        function createLightning(centerX, centerY) {
            const numBolts = Math.random() * 4 + 3; // More bolts
            
            for (let i = 0; i < numBolts; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 30 + 20; // Smaller distance
                const endX = centerX + Math.cos(angle) * distance;
                const endY = centerY + Math.sin(angle) * distance;
                
                lightningBolts.push(new LightningBolt(centerX, centerY, endX, endY));
            }
        }
        
        // Draw animated, irregular glowing aura around cursor
        function drawGlowAura(ctx, x, y, intensity) {
            ctx.save();
            
            // Animated glow parameters
            const time = Date.now() * 0.005;
            const pulse1 = 0.7 + 0.3 * Math.sin(time * 2);
            const pulse2 = 0.6 + 0.4 * Math.sin(time * 3.5);
            const pulse3 = 0.8 + 0.2 * Math.sin(time * 1.5);
            
            // Irregular glow with multiple animated layers
            const baseRadius = 40;
            const layers = [
                { radius: baseRadius * pulse1, intensity: intensity * 0.4, color: 'rgba(255, 255, 255, ' },
                { radius: baseRadius * 1.5 * pulse2, intensity: intensity * 0.3, color: 'rgba(100, 149, 237, ' },
                { radius: baseRadius * 2 * pulse3, intensity: intensity * 0.2, color: 'rgba(30, 144, 255, ' },
                { radius: baseRadius * 2.5 * pulse1, intensity: intensity * 0.1, color: 'rgba(65, 105, 225, ' }
            ];
            
            layers.forEach(layer => {
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, layer.radius);
                gradient.addColorStop(0, layer.color + (layer.intensity * 0.8) + ')');
                gradient.addColorStop(0.4, layer.color + (layer.intensity * 0.4) + ')');
                gradient.addColorStop(0.8, layer.color + (layer.intensity * 0.1) + ')');
                gradient.addColorStop(1, layer.color + '0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x - layer.radius, y - layer.radius, layer.radius * 2, layer.radius * 2);
            });
            
            // Add sparkling effect
            for (let i = 0; i < 8; i++) {
                const sparkleAngle = time * 2 + i * Math.PI / 4;
                const sparkleRadius = 25 + 10 * Math.sin(time * 3 + i);
                const sparkleX = x + Math.cos(sparkleAngle) * sparkleRadius;
                const sparkleY = y + Math.sin(sparkleAngle) * sparkleRadius;
                const sparkleSize = 2 + Math.sin(time * 4 + i) * 1;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.8})`;
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // Animation loop for effects
        function animateEffects() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw lightning bolts
            lightningBolts = lightningBolts.filter(bolt => {
                bolt.update();
                bolt.draw(ctx);
                return bolt.life > 0;
            });
            
            // Only show effects when actively pressed
            if (isEffectsActive && glowIntensity > 0) {
                drawGlowAura(ctx, mouseX, mouseY, glowIntensity);
                
                // Create continuous lightning while pressed
                const now = Date.now();
                if (now - lastLightningTime > 150 + Math.random() * 300) {
                    createLightning(mouseX, mouseY);
                    lastLightningTime = now;
                }
            }
            
            // Gradually fade the glow when not pressed
            if (!isEffectsActive) {
                glowIntensity *= 0.92;
            }
            
            requestAnimationFrame(animateEffects);
        }
        
        // Start animation loop
        animateEffects();
        
        // Track mouse/touch position for effects
        function updateEffectsPosition(clientX, clientY) {
            mouseX = clientX;
            mouseY = clientY;
        }
        
        // Mouse events for effects (position tracking only)
        document.addEventListener('mousemove', (e) => {
            updateEffectsPosition(e.clientX, e.clientY);
        });
        
        // Touch events for effects (position tracking only)
        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                updateEffectsPosition(e.touches[0].clientX, e.touches[0].clientY);
            }
        });
        
        // Timer state management
        let timerState = 'idle'; // 'idle', 'ready', 'running', 'stopped'
        let startTime = 0;
        let timerInterval = null;
        let scores = JSON.parse(localStorage.getItem('timer-scores') || '[]');
        
        // DOM elements
        const timerEl = document.getElementById('timer');
        const statusEl = document.getElementById('status');
        const instructionsEl = document.getElementById('instructions');
        const leaderboardEl = document.getElementById('leaderboard');
        const scoresContainer = document.getElementById('scores-container');

        // Universal input handling - works for both mouse and touch
        let isPressed = false;

        // Mouse events (PC)
        document.addEventListener('mousedown', handlePressStart);
        document.addEventListener('mouseup', handlePressEnd);

        // Touch events (Mobile)
        document.addEventListener('touchstart', handlePressStart);
        document.addEventListener('touchend', handlePressEnd);

        // Prevent context menu on long press
        document.addEventListener('contextmenu', e => e.preventDefault());

        function handlePressStart(event) {
            event.preventDefault();
            
            // Update effects position
            if (event.type === 'mousedown') {
                updateEffectsPosition(event.clientX, event.clientY);
            } else if (event.type === 'touchstart' && event.touches.length > 0) {
                updateEffectsPosition(event.touches[0].clientX, event.touches[0].clientY);
            }
            
            // Activate effects and create initial lightning burst
            isEffectsActive = true;
            glowIntensity = 1.0;
            createLightning(mouseX, mouseY);
            
            if (isPressed) return; // Prevent multiple triggers
            isPressed = true;

            if (timerState === 'idle') {
                // First press - prepare timer
                timerState = 'ready';
                instructionsEl.style.display = 'none';
                leaderboardEl.style.display = 'none';
                timerEl.style.display = 'flex';
                timerEl.textContent = '0.000s';
                statusEl.textContent = 'Release to start timing...';
                statusEl.style.color = 'dodgerblue';
            } else if (timerState === 'running') {
                // Second press - stop timer
                stopTimer();
            }
        }

        function handlePressEnd(event) {
            event.preventDefault();
            
            // Deactivate effects and create final lightning burst
            isEffectsActive = false;
            if (mouseX > 0 && mouseY > 0) {
                createLightning(mouseX, mouseY);
            }
            
            if (!isPressed) return;
            isPressed = false;

            if (timerState === 'ready') {
                // Release after first press - start timer
                startTimer();
            }
        }

        function startTimer() {
            timerState = 'running';
            startTime = Date.now();
            statusEl.textContent = 'Press anywhere to stop...';
            statusEl.style.color = '#333366';
            
            // Update timer display every 10ms for smooth animation
            timerInterval = setInterval(() => {
                const elapsed = (Date.now() - startTime) / 1000;
                timerEl.textContent = elapsed.toFixed(3) + 's';
            }, 10);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            const finalTime = (Date.now() - startTime) / 1000;
            timerEl.textContent = finalTime.toFixed(3) + 's';
            
            // Save score
            saveScore(finalTime);
            
            timerState = 'stopped';
            statusEl.textContent = `Time saved: ${finalTime.toFixed(3)}s - Press anywhere to start again`;
            statusEl.style.color = 'green';
            
            // Show leaderboard after a short delay
            setTimeout(() => {
                showLeaderboard();
                timerState = 'idle';
            }, 1500);
        }

        function saveScore(time) {
            scores.push(time);
            // Sort scores (best times first)
            scores.sort((a, b) => a - b);
            // Keep only top 5
            scores = scores.slice(0, 5);
            // Save to localStorage
            localStorage.setItem('timer-scores', JSON.stringify(scores));
        }

        function showLeaderboard() {
            if (scores.length === 0) {
                statusEl.textContent = 'No scores yet. Press anywhere to start timing!';
                statusEl.style.color = '#555555';
                return;
            }

            updateLeaderboardDisplay();
            leaderboardEl.style.display = 'block';
            timerEl.style.display = 'none';
            statusEl.textContent = 'Press anywhere to start a new timer';
            statusEl.style.color = '#555555';
        }

        function updateLeaderboardDisplay() {
            scoresContainer.innerHTML = '';
            
            scores.forEach((score, index) => {
                const scoreEntry = document.createElement('div');
                scoreEntry.className = 'score-entry';
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : 'üèÖ';
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.textContent = 'Delete';
                let deleteDebounce = false;
                deleteBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (deleteDebounce) return;
                    deleteDebounce = true;
                    setTimeout(() => { deleteDebounce = false; }, 300);
                    deleteScore(index, true);
                });
                const scoreSpan = document.createElement('span');
                scoreSpan.textContent = `${medal} ${index + 1}. ${score.toFixed(3)}s`;
                scoreEntry.appendChild(scoreSpan);
                scoreEntry.appendChild(deleteBtn);
                scoresContainer.appendChild(scoreEntry);
            });
        }

function deleteScore(index, stayOnLeaderboard) {
    scores.splice(index, 1);
    localStorage.setItem('timer-scores', JSON.stringify(scores));
    updateLeaderboardDisplay();
    if (scores.length === 0) {
        leaderboardEl.style.display = 'none';
        statusEl.textContent = 'All scores deleted. Press anywhere to start timing!';
        statusEl.style.color = '#555555';
    } else if (stayOnLeaderboard) {
        leaderboardEl.style.display = 'block';
        timerEl.style.display = 'none';
        statusEl.textContent = 'Press anywhere to start a new timer';
        statusEl.style.color = '#555555';
    }
}

        // Show leaderboard on page load if there are scores
        if (scores.length > 0) {
            setTimeout(() => {
                showLeaderboard();
            }, 1000);
        }

        // Prevent scrolling and zooming on mobile
        document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('gesturechange', e => e.preventDefault());
        document.addEventListener('gestureend', e => e.preventDefault());
    </script>
</body>
</html>
